\documentclass{article}
% =======PACKAGES=======
% FORMATTING
\usepackage[margin=0.625in]{geometry}
\usepackage{parskip, setspace}
\setstretch{1.15}
% TYPESETTING - MATH
\usepackage{amsmath, amsfonts}
\usepackage[ruled, linesnumbered, noend]{algorithm2e}
\usepackage{listings}
\usepackage{xcolor}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{lightgray},   
    commentstyle=\color{darkgray},
    keywordstyle=\color{red},
    numberstyle=\color{black},
    stringstyle=\color{violet},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}
% RICH
\usepackage{graphicx, caption}
\usepackage{hyperref}
% BIBLIOGRAPHY
\usepackage[
backend=biber,
sorting=ynt
]{biblatex}
\addbibresource{sem_1.bib}

% =======TITLE=======
\title{\vspace*{-0.625in}CS 565: Scientific Computing \\ Seminar 1: Psuedo-Random Number Generators}
\author{Nathan Chapman}
\date{\today}

\begin{document}

    \maketitle

    \section*{Introduction}

        \begin{itemize}
            \item What was used before these methods?  Was there a standard go-to?
            \item What hole do these fill?
            \item Other methods than mathematical generation?  e.g. physical generation?
        \end{itemize}
    
    \section*{Methods}

        The standard library of the Julia programming language, contains several algorithms to generate psuedo-random numbers\cite{Julia-2017}: \texttt{TaskLocalRNG, Xoshiro, RandomDevice}, and \texttt{MersenneTwister}.

        % \begin{itemize}
        %     \item TaskLocalRNG: a token that represents use of the currently active Task-local stream, deterministically seeded from the parent task, or by RandomDevice (with system randomness) at program start
        %     \item Xoshiro: generates a high-quality stream of random numbers with a small state vector and high performance using the Xoshiro256++ algorithm
        %     \item RandomDevice: for OS-provided entropy. This may be used for cryptographically secure random numbers (CS(P)RNG).
        %     \item MersenneTwister: an alternate high-quality PRNG which was the default in older versions of Julia, and is also quite fast, but requires much more space to store the state vector and generate a random sequence.
        %     \item Parallel versions
        %     \item Sample from normal or exponential distribution
        %     \item stableRNGs and Lehmer random number generator
        % \end{itemize}

        \subsection*{TaskLocalRNG}

        According to the Julia documentation\cite{Julia-2017}:

            \begin{quote}
                \textit{The \texttt{TaskLocalRNG} has state that is local to its task, not its thread. It is seeded upon task creation, from the state of its parent task. Therefore, task creation is an event that changes the parent's RNG state.}

                \textit{As an upside, the \texttt{TaskLocalRNG} is pretty fast, and permits reproducible multithreaded simulations (barring race conditions), independent of scheduler decisions. As long as the number of threads is not used to make decisions on task creation, simulation results are also independent of the number of available threads / CPUs. The random stream should not depend on hardware specifics, up to endianness and possibly word size.}
            \end{quote}

        \subsection*{Xoshiro256++}

            The following statements come from \cite{XoroshiroPaper} or \cite{Shootout}
            \begin{itemize}
                \item xor\_o\_shi\_ro = XOR/shift/rotate
                \item sub ns speed
                \item state space of 256 bits
                \item if you only need 64-bit floats, xoshiro256+ is 15\% faster with the same properties
                \item period of $2^{256} - 1$
                \item provides $2^{128}$ non-overlapping sequences of length $2^{128}$
                \item lowest bits have low linear complexity
                \item xoroshiro128 family is the same speed in half the space (suitable for low-scale parallelism)
                \item xoshiro128 family is 32 bits and thus applicable to be used on GPUs
                \item equidistribution: every n/64-tuple of consecutive 64-bit values appears exactly once in the output, except for the zero tuple (and this is the largest possible dimension).
                \item \href{https://prng.di.unimi.it/xoshiro256plusplus.c}{C code}
                \item platforms: javascript, rust, java, .net, erlang, FORTRAN, julia, lua, IoT (mbed and zephyr)
            \end{itemize}

            \begin{quote}
                \textit{Julia's Xoshiro implementation has a bulk-generation mode; this seeds new virtual PRNGs from the parent, and uses SIMD to generate in parallel (i.e. the bulk stream consists of multiple interleaved xoshiro instances). The virtual PRNGs are discarded once the bulk request has been serviced (and should cause no heap allocations).}
            \end{quote}

        \subsection*{Congruential arithmetic}

            \begin{itemize}
                \item need 128-bit operations.
            \end{itemize}

        \subsection*{RandomDevice}
        
        \subsection*{MersenneTwister}

            \begin{itemize}
                \item platforms: many programming languages, most notably Python\cite{Python}, Microsoft Excel\cite{Excel}, MATLAB\cite{MATLAB}, C++\cite{Cpp}
            \end{itemize}

    \section*{Results}

        \begin{itemize}
            \item Show these algorithms in practice
            \item Quality\cite{Shootout}: Compare xoshiro and relatives using BigCrush suite of tests \cite{TestU01} and \cite{HammingWeightDependencies}
            \item Vectorization using AVX2 (Advanced Vector Extensions) vectorization \cite{Shootout}
        \end{itemize}

    \section*{Discussion}

        \begin{itemize}
            \item Compare and contrast each of these algorithms
        \end{itemize}

    \section*{Conclusion}

    \printbibliography

\end{document}